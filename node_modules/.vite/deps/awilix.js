import "./chunk-CEQRFMJQ.js";

// node_modules/awilix/lib/awilix.browser.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var EOL = "\n";
var ExtendableError = (
  /** @class */
  function(_super) {
    __extends(ExtendableError2, _super);
    function ExtendableError2(message) {
      var _this = _super.call(this, message) || this;
      Object.defineProperty(_this, "message", {
        enumerable: false,
        value: message
      });
      Object.defineProperty(_this, "name", {
        enumerable: false,
        value: _this.constructor.name
      });
      if ("captureStackTrace" in Error) {
        Error.captureStackTrace(_this, _this.constructor);
      } else {
        Object.defineProperty(_this, "stack", {
          enumerable: false,
          value: Error(message).stack,
          writable: true,
          configurable: true
        });
      }
      return _this;
    }
    return ExtendableError2;
  }(Error)
);
var AwilixError = (
  /** @class */
  function(_super) {
    __extends(AwilixError2, _super);
    function AwilixError2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return AwilixError2;
  }(ExtendableError)
);
var AwilixTypeError = (
  /** @class */
  function(_super) {
    __extends(AwilixTypeError2, _super);
    function AwilixTypeError2(funcDescription, paramName, expectedType, givenType) {
      return _super.call(this, "".concat(funcDescription, ": expected ").concat(paramName, " to be ").concat(expectedType, ", but got ").concat(givenType, ".")) || this;
    }
    AwilixTypeError2.assert = function(condition, funcDescription, paramName, expectedType, givenType) {
      if (!condition) {
        throw new AwilixTypeError2(funcDescription, paramName, expectedType, givenType);
      }
      return condition;
    };
    return AwilixTypeError2;
  }(AwilixError)
);
var AwilixResolutionError = (
  /** @class */
  function(_super) {
    __extends(AwilixResolutionError2, _super);
    function AwilixResolutionError2(name, resolutionStack, message) {
      var stringName = name.toString();
      var nameStack = resolutionStack.map(function(_a) {
        var val = _a.name;
        return val.toString();
      });
      nameStack.push(stringName);
      var resolutionPathString = nameStack.join(" -> ");
      var msg = "Could not resolve '".concat(stringName, "'.");
      if (message) {
        msg += " ".concat(message);
      }
      msg += EOL + EOL;
      msg += "Resolution path: ".concat(resolutionPathString);
      return _super.call(this, msg) || this;
    }
    return AwilixResolutionError2;
  }(AwilixError)
);
var AwilixRegistrationError = (
  /** @class */
  function(_super) {
    __extends(AwilixRegistrationError2, _super);
    function AwilixRegistrationError2(name, message) {
      var stringName = name.toString();
      var msg = "Could not register '".concat(stringName, "'.");
      if (message) {
        msg += " ".concat(message);
      }
      return _super.call(this, msg) || this;
    }
    return AwilixRegistrationError2;
  }(AwilixError)
);
var InjectionMode = {
  /**
   * The dependencies will be resolved by injecting the cradle proxy.
   *
   * @type {String}
   */
  PROXY: "PROXY",
  /**
   * The dependencies will be resolved by inspecting parameter names of the function/constructor.
   *
   * @type {String}
   */
  CLASSIC: "CLASSIC"
};
var Lifetime = {
  /**
   * The registration will be resolved once and only once.
   * @type {String}
   */
  SINGLETON: "SINGLETON",
  /**
   * The registration will be resolved every time (never cached).
   * @type {String}
   */
  TRANSIENT: "TRANSIENT",
  /**
   * The registration will be resolved once per scope.
   * @type {String}
   */
  SCOPED: "SCOPED"
};
function isLifetimeLonger(a, b) {
  return a === Lifetime.SINGLETON && b !== Lifetime.SINGLETON || a === Lifetime.SCOPED && b === Lifetime.TRANSIENT;
}
function createTokenizer(source) {
  var end = source.length;
  var pos = 0;
  var type = "EOF";
  var value = "";
  var flags = 0;
  var parenLeft = 0;
  var parenRight = 0;
  return {
    next,
    done
  };
  function next(nextFlags) {
    if (nextFlags === void 0) {
      nextFlags = 0;
    }
    flags = nextFlags;
    advance();
    return createToken();
  }
  function advance() {
    value = "";
    type = "EOF";
    while (true) {
      if (pos >= end) {
        return type = "EOF";
      }
      var ch = source.charAt(pos);
      if (isWhiteSpace(ch)) {
        pos++;
        continue;
      }
      switch (ch) {
        case "(":
          pos++;
          parenLeft++;
          return type = ch;
        case ")":
          pos++;
          parenRight++;
          return type = ch;
        case "*":
          pos++;
          return type = ch;
        case ",":
          pos++;
          return type = ch;
        case "=":
          pos++;
          if ((flags & 1) === 0) {
            skipExpression();
          }
          return type = ch;
        case "/": {
          pos++;
          var nextCh = source.charAt(pos);
          if (nextCh === "/") {
            skipUntil(function(c) {
              return c === "\n";
            }, true);
            pos++;
          }
          if (nextCh === "*") {
            skipUntil(function(c) {
              var closing = source.charAt(pos + 1);
              return c === "*" && closing === "/";
            }, true);
            pos++;
          }
          continue;
        }
        default:
          if (isIdentifierStart(ch)) {
            scanIdentifier();
            return type;
          }
          pos++;
      }
    }
  }
  function scanIdentifier() {
    var identStart = source.charAt(pos);
    var start = ++pos;
    while (isIdentifierPart(source.charAt(pos))) {
      pos++;
    }
    value = "" + identStart + source.substring(start, pos);
    type = value === "function" || value === "class" ? value : "ident";
    if (type !== "ident") {
      value = "";
    }
    return value;
  }
  function skipExpression() {
    skipUntil(function(ch) {
      var isAtRoot = parenLeft === parenRight + 1;
      if (ch === "," && isAtRoot) {
        return true;
      }
      if (ch === "(") {
        parenLeft++;
        return false;
      }
      if (ch === ")") {
        parenRight++;
        if (isAtRoot) {
          return true;
        }
      }
      return false;
    });
  }
  function skipUntil(callback, dumb) {
    if (dumb === void 0) {
      dumb = false;
    }
    while (pos < source.length) {
      var ch = source.charAt(pos);
      if (callback(ch)) {
        return;
      }
      if (!dumb) {
        if (isWhiteSpace(ch)) {
          pos++;
          continue;
        }
        if (isStringQuote(ch)) {
          skipString();
          continue;
        }
      }
      pos++;
    }
  }
  function skipString() {
    var quote = source.charAt(pos);
    pos++;
    while (pos < source.length) {
      var ch = source.charAt(pos);
      var prev = source.charAt(pos - 1);
      if (ch === quote && prev !== "\\") {
        pos++;
        return;
      }
      if (quote === "`") {
        var next_1 = source.charAt(pos + 1);
        if (next_1 === "$") {
          var afterDollar = source.charAt(pos + 2);
          if (afterDollar === "{") {
            pos = pos + 2;
            skipUntil(function(ch2) {
              return ch2 === "}";
            });
          }
        }
      }
      pos++;
    }
  }
  function createToken() {
    if (value) {
      return { value, type };
    }
    return { type };
  }
  function done() {
    return type === "EOF";
  }
}
function isWhiteSpace(ch) {
  switch (ch) {
    case "\r":
    case "\n":
    case " ":
      return true;
  }
  return false;
}
function isStringQuote(ch) {
  switch (ch) {
    case "'":
    case '"':
    case "`":
      return true;
  }
  return false;
}
var IDENT_START_EXPR = /^[_$a-zA-Z\xA0-\uFFFF]$/;
var IDENT_PART_EXPR = /^[._$a-zA-Z0-9\xA0-\uFFFF]$/;
function isIdentifierStart(ch) {
  return IDENT_START_EXPR.test(ch);
}
function isIdentifierPart(ch) {
  return IDENT_PART_EXPR.test(ch);
}
function nameValueToObject(name, value) {
  var _a;
  var obj = name;
  if (typeof obj === "string" || typeof obj === "symbol") {
    return _a = {}, _a[name] = value, _a;
  }
  return obj;
}
function last(arr) {
  return arr[arr.length - 1];
}
function isClass(fn) {
  if (typeof fn !== "function") {
    return false;
  }
  var tokenizer = createTokenizer(fn.toString());
  var first = tokenizer.next();
  if (first.type === "class") {
    return true;
  }
  var second = tokenizer.next();
  if (first.type === "function" && second.value) {
    if (second.value[0] === second.value[0].toUpperCase()) {
      return true;
    }
  }
  return false;
}
function isFunction(val) {
  return typeof val === "function";
}
function uniq(arr) {
  return Array.from(new Set(arr));
}
function parseParameterList(source) {
  var _a = createTokenizer(source), _next = _a.next, done = _a.done;
  var params = [];
  var t = null;
  nextToken();
  while (!done()) {
    switch (t.type) {
      case "class":
        skipUntilConstructor();
        if (!isConstructorToken()) {
          return null;
        }
        nextToken();
        break;
      case "function": {
        var next = nextToken();
        if (next.type === "ident" || next.type === "*") {
          nextToken();
        }
        break;
      }
      case "(":
        parseParams();
        break;
      case ")":
        return params;
      case "ident": {
        var param = { name: t.value, optional: false };
        if (t.value === "async") {
          var next = nextToken();
          if (next && next.type !== "=") {
            break;
          }
        }
        params.push(param);
        return params;
      }
      default:
        throw unexpected();
    }
  }
  return params;
  function parseParams() {
    var param2 = { name: "", optional: false };
    while (!done()) {
      nextToken();
      switch (t.type) {
        case "ident":
          param2.name = t.value;
          break;
        case "=":
          param2.optional = true;
          break;
        case ",":
          params.push(param2);
          param2 = { name: "", optional: false };
          break;
        case ")":
          if (param2.name) {
            params.push(param2);
          }
          return;
        default:
          throw unexpected();
      }
    }
  }
  function skipUntilConstructor() {
    while (!isConstructorToken() && !done()) {
      nextToken(
        1
        /* TokenizerFlags.Dumb */
      );
    }
  }
  function isConstructorToken() {
    return t.type === "ident" && t.value === "constructor";
  }
  function nextToken(flags) {
    if (flags === void 0) {
      flags = 0;
    }
    t = _next(flags);
    return t;
  }
  function unexpected() {
    return new SyntaxError("Parsing parameter list, did not expect ".concat(t.type, " token").concat(t.value ? " (".concat(t.value, ")") : ""));
  }
}
var RESOLVER = Symbol("Awilix Resolver Config");
function asValue(value) {
  return {
    resolve: function() {
      return value;
    },
    isLeakSafe: true
  };
}
function asFunction(fn, opts) {
  if (!isFunction(fn)) {
    throw new AwilixTypeError("asFunction", "fn", "function", fn);
  }
  var defaults = {
    lifetime: Lifetime.TRANSIENT
  };
  opts = makeOptions(defaults, opts, fn[RESOLVER]);
  var resolve = generateResolve(fn);
  var result = __assign({ resolve }, opts);
  return createDisposableResolver(createBuildResolver(result));
}
function asClass(Type, opts) {
  if (!isFunction(Type)) {
    throw new AwilixTypeError("asClass", "Type", "class", Type);
  }
  var defaults = {
    lifetime: Lifetime.TRANSIENT
  };
  opts = makeOptions(defaults, opts, Type[RESOLVER]);
  var newClass = function newClass2() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return Reflect.construct(Type, args);
  };
  var resolve = generateResolve(newClass, Type);
  return createDisposableResolver(createBuildResolver(__assign(__assign({}, opts), { resolve })));
}
function aliasTo(name) {
  return {
    resolve: function(container) {
      return container.resolve(name);
    },
    isLeakSafe: true
  };
}
function createBuildResolver(obj) {
  function setLifetime(value) {
    return createBuildResolver(__assign(__assign({}, this), { lifetime: value }));
  }
  function setInjectionMode(value) {
    return createBuildResolver(__assign(__assign({}, this), { injectionMode: value }));
  }
  function inject(injector) {
    return createBuildResolver(__assign(__assign({}, this), { injector }));
  }
  return updateResolver(obj, {
    setLifetime,
    inject,
    transient: partial(setLifetime, Lifetime.TRANSIENT),
    scoped: partial(setLifetime, Lifetime.SCOPED),
    singleton: partial(setLifetime, Lifetime.SINGLETON),
    setInjectionMode,
    proxy: partial(setInjectionMode, InjectionMode.PROXY),
    classic: partial(setInjectionMode, InjectionMode.CLASSIC)
  });
}
function createDisposableResolver(obj) {
  function disposer(dispose) {
    return createDisposableResolver(__assign(__assign({}, this), { dispose }));
  }
  return updateResolver(obj, {
    disposer
  });
}
function partial(fn, arg1) {
  return function partiallyApplied() {
    return fn.call(this, arg1);
  };
}
function makeOptions(defaults) {
  var rest = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest[_i - 1] = arguments[_i];
  }
  return Object.assign.apply(Object, __spreadArray([{}, defaults], rest, false));
}
function updateResolver(source, target) {
  var result = __assign(__assign({}, source), target);
  return result;
}
function wrapWithLocals(container, locals) {
  return function wrappedResolve(name, resolveOpts) {
    if (name in locals) {
      return locals[name];
    }
    return container.resolve(name, resolveOpts);
  };
}
function createInjectorProxy(container, injector) {
  var locals = injector(container);
  var allKeys = uniq(__spreadArray(__spreadArray([], Reflect.ownKeys(container.cradle), true), Reflect.ownKeys(locals), true));
  var proxy = new Proxy({}, {
    /**
     * Resolves the value by first checking the locals, then the container.
     */
    get: function(target, name) {
      if (name === Symbol.iterator) {
        return function iterateRegistrationsAndLocals() {
          var _a, _b, _c, _i, prop, _d, _e, _f, _g, prop;
          return __generator(this, function(_h) {
            switch (_h.label) {
              case 0:
                _a = container.cradle;
                _b = [];
                for (_c in _a)
                  _b.push(_c);
                _i = 0;
                _h.label = 1;
              case 1:
                if (!(_i < _b.length))
                  return [3, 4];
                _c = _b[_i];
                if (!(_c in _a))
                  return [3, 3];
                prop = _c;
                return [4, prop];
              case 2:
                _h.sent();
                _h.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                _d = locals;
                _e = [];
                for (_f in _d)
                  _e.push(_f);
                _g = 0;
                _h.label = 5;
              case 5:
                if (!(_g < _e.length))
                  return [3, 8];
                _f = _e[_g];
                if (!(_f in _d))
                  return [3, 7];
                prop = _f;
                return [4, prop];
              case 6:
                _h.sent();
                _h.label = 7;
              case 7:
                _g++;
                return [3, 5];
              case 8:
                return [
                  2
                  /*return*/
                ];
            }
          });
        };
      }
      if (name in locals) {
        return locals[name];
      }
      return container.resolve(name);
    },
    /**
     * Used for `Object.keys`.
     */
    ownKeys: function() {
      return allKeys;
    },
    /**
     * Used for `Object.keys`.
     */
    getOwnPropertyDescriptor: function(target, key) {
      if (allKeys.indexOf(key) > -1) {
        return {
          enumerable: true,
          configurable: true
        };
      }
      return void 0;
    }
  });
  return proxy;
}
function generateResolve(fn, dependencyParseTarget) {
  if (!dependencyParseTarget) {
    dependencyParseTarget = fn;
  }
  var dependencies = parseDependencies(dependencyParseTarget);
  return function resolve(container) {
    var injectionMode = this.injectionMode || container.options.injectionMode || InjectionMode.PROXY;
    if (injectionMode !== InjectionMode.CLASSIC) {
      var cradle = this.injector ? createInjectorProxy(container, this.injector) : container.cradle;
      return fn(cradle);
    }
    if (dependencies.length > 0) {
      var resolve_1 = this.injector ? wrapWithLocals(container, this.injector(container)) : container.resolve;
      var children = dependencies.map(function(p) {
        return resolve_1(p.name, { allowUnregistered: p.optional });
      });
      return fn.apply(void 0, children);
    }
    return fn();
  };
}
function parseDependencies(fn) {
  var result = parseParameterList(fn.toString());
  if (!result) {
    var parent = Object.getPrototypeOf(fn);
    if (typeof parent === "function" && parent !== Function.prototype) {
      return parseDependencies(parent);
    }
    return [];
  }
  return result;
}
var FAMILY_TREE = Symbol("familyTree");
var ROLL_UP_REGISTRATIONS = Symbol("rollUpRegistrations");
var CRADLE_STRING_TAG = "AwilixContainerCradle";
function createContainer(options) {
  if (options === void 0) {
    options = {};
  }
  return createContainerInternal(options);
}
function createContainerInternal(options, parentContainer, parentResolutionStack) {
  var _a;
  options = __assign({ injectionMode: InjectionMode.PROXY, strict: false }, options);
  var resolutionStack = parentResolutionStack !== null && parentResolutionStack !== void 0 ? parentResolutionStack : [];
  var registrations = {};
  var cradle = new Proxy({
    /* removed in browser build */
  }, {
    /**
     * The `get` handler is invoked whenever a get-call for `container.cradle.*` is made.
     *
     * @param  {object} _target
     * The proxy target. Irrelevant.
     *
     * @param  {string} name
     * The property name.
     *
     * @return {*}
     * Whatever the resolve call returns.
     */
    get: function(_target, name) {
      return resolve(name);
    },
    /**
     * Setting things on the cradle throws an error.
     *
     * @param  {object} target
     * @param  {string} name
     */
    set: function(_target, name) {
      throw new Error('Attempted setting property "'.concat(name, '" on container cradle - this is not allowed.'));
    },
    /**
     * Used for `Object.keys`.
     */
    ownKeys: function() {
      return Array.from(cradle);
    },
    /**
     * Used for `Object.keys`.
     */
    getOwnPropertyDescriptor: function(target, key) {
      var regs = rollUpRegistrations();
      if (Object.getOwnPropertyDescriptor(regs, key)) {
        return {
          enumerable: true,
          configurable: true
        };
      }
      return void 0;
    }
  });
  var container = (_a = {
    options,
    cradle,
    inspect,
    cache: /* @__PURE__ */ new Map(),
    loadModules: function() {
      throw new Error("loadModules is not supported in the browser.");
    },
    createScope,
    register,
    build,
    resolve,
    hasRegistration,
    dispose,
    getRegistration
  }, /* removed in browser build */
  // tslint:disable-next-line
  _a[ROLL_UP_REGISTRATIONS] = rollUpRegistrations, Object.defineProperty(_a, "registrations", {
    get: function() {
      return rollUpRegistrations();
    },
    enumerable: false,
    configurable: true
  }), _a);
  var familyTree = parentContainer ? [container].concat(parentContainer[FAMILY_TREE]) : [container];
  container[FAMILY_TREE] = familyTree;
  var rootContainer = last(familyTree);
  return container;
  function inspect() {
    return "[AwilixContainer (".concat(parentContainer ? "scoped, " : "", "registrations: ").concat(Object.keys(container.registrations).length, ")]");
  }
  function rollUpRegistrations() {
    return __assign(__assign({}, parentContainer && parentContainer[ROLL_UP_REGISTRATIONS]()), registrations);
  }
  function cradleIterator() {
    var registrations2, _a2, _b, _c, _i, registrationName;
    return __generator(this, function(_d) {
      switch (_d.label) {
        case 0:
          registrations2 = rollUpRegistrations();
          _a2 = registrations2;
          _b = [];
          for (_c in _a2)
            _b.push(_c);
          _i = 0;
          _d.label = 1;
        case 1:
          if (!(_i < _b.length))
            return [3, 4];
          _c = _b[_i];
          if (!(_c in _a2))
            return [3, 3];
          registrationName = _c;
          return [4, registrationName];
        case 2:
          _d.sent();
          _d.label = 3;
        case 3:
          _i++;
          return [3, 1];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  }
  function createScope() {
    return createContainerInternal(options, container, resolutionStack);
  }
  function register(arg1, arg2) {
    var obj = nameValueToObject(arg1, arg2);
    var keys = __spreadArray(__spreadArray([], Object.keys(obj), true), Object.getOwnPropertySymbols(obj), true);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
      var key = keys_1[_i];
      var resolver = obj[key];
      if (options.strict && resolver.lifetime === Lifetime.SINGLETON) {
        if (parentContainer) {
          throw new AwilixRegistrationError(key, "Cannot register a singleton on a scoped container.");
        }
      }
      registrations[key] = resolver;
    }
    return container;
  }
  function toStringRepresentationFn() {
    return Object.prototype.toString.call(cradle);
  }
  function getRegistration(name) {
    var resolver = registrations[name];
    if (resolver) {
      return resolver;
    }
    if (parentContainer) {
      return parentContainer.getRegistration(name);
    }
    return null;
  }
  function resolve(name, resolveOpts) {
    resolveOpts = resolveOpts || {};
    try {
      var resolver = getRegistration(name);
      if (resolutionStack.some(function(_a2) {
        var parentName = _a2.name;
        return parentName === name;
      })) {
        throw new AwilixResolutionError(name, resolutionStack, "Cyclic dependencies detected.");
      }
      if (name === "toJSON") {
        return toStringRepresentationFn;
      }
      if (name === "constructor") {
        return createContainer;
      }
      if (!resolver) {
        switch (name) {
          case "inspect":
          case "toString":
            return toStringRepresentationFn;
          case Symbol.toStringTag:
            return CRADLE_STRING_TAG;
          case "then":
            return void 0;
          case Symbol.iterator:
            return cradleIterator;
        }
        if (resolveOpts.allowUnregistered) {
          return void 0;
        }
        throw new AwilixResolutionError(name, resolutionStack);
      }
      var lifetime_1 = resolver.lifetime || Lifetime.TRANSIENT;
      if (options.strict && !resolver.isLeakSafe) {
        var maybeLongerLifetimeParentIndex = resolutionStack.findIndex(function(_a2) {
          var parentLifetime = _a2.lifetime;
          return isLifetimeLonger(parentLifetime, lifetime_1);
        });
        if (maybeLongerLifetimeParentIndex > -1) {
          throw new AwilixResolutionError(name, resolutionStack, "Dependency '".concat(name.toString(), "' has a shorter lifetime than its ancestor: '").concat(resolutionStack[maybeLongerLifetimeParentIndex].name.toString(), "'"));
        }
      }
      resolutionStack.push({ name, lifetime: lifetime_1 });
      var cached = void 0;
      var resolved = void 0;
      switch (lifetime_1) {
        case Lifetime.TRANSIENT:
          resolved = resolver.resolve(container);
          break;
        case Lifetime.SINGLETON:
          cached = rootContainer.cache.get(name);
          if (!cached) {
            resolved = resolver.resolve(options.strict ? rootContainer : container);
            rootContainer.cache.set(name, { resolver, value: resolved });
          } else {
            resolved = cached.value;
          }
          break;
        case Lifetime.SCOPED:
          cached = container.cache.get(name);
          if (cached !== void 0) {
            resolved = cached.value;
            break;
          }
          resolved = resolver.resolve(container);
          container.cache.set(name, { resolver, value: resolved });
          break;
        default:
          throw new AwilixResolutionError(name, resolutionStack, 'Unknown lifetime "'.concat(resolver.lifetime, '"'));
      }
      resolutionStack.pop();
      return resolved;
    } catch (err) {
      resolutionStack.length = 0;
      throw err;
    }
  }
  function hasRegistration(name) {
    return !!getRegistration(name);
  }
  function build(targetOrResolver, opts) {
    if (targetOrResolver && targetOrResolver.resolve) {
      return targetOrResolver.resolve(container);
    }
    var funcName = "build";
    var paramName = "targetOrResolver";
    AwilixTypeError.assert(targetOrResolver, funcName, paramName, "a registration, function or class", targetOrResolver);
    AwilixTypeError.assert(typeof targetOrResolver === "function", funcName, paramName, "a function or class", targetOrResolver);
    var resolver = isClass(targetOrResolver) ? asClass(targetOrResolver, opts) : asFunction(targetOrResolver, opts);
    return resolver.resolve(container);
  }
  function dispose() {
    var entries = Array.from(container.cache.entries());
    container.cache.clear();
    return Promise.all(entries.map(function(_a2) {
      var entry = _a2[1];
      var resolver = entry.resolver, value = entry.value;
      var disposable = resolver;
      if (disposable.dispose) {
        return Promise.resolve().then(function() {
          return disposable.dispose(value);
        });
      }
      return Promise.resolve();
    })).then(function() {
      return void 0;
    });
  }
}
export {
  AwilixError,
  AwilixRegistrationError,
  AwilixResolutionError,
  AwilixTypeError,
  InjectionMode,
  Lifetime,
  RESOLVER,
  aliasTo,
  asClass,
  asFunction,
  asValue,
  createBuildResolver,
  createContainer,
  createDisposableResolver
};
//# sourceMappingURL=awilix.js.map
