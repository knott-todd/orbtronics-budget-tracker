{
  "version": 3,
  "sources": ["../../awilix/lib/awilix.browser.js"],
  "sourcesContent": ["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * Newline.\n */\nvar EOL = '\\n';\n/**\n * An extendable error class.\n * @author https://github.com/bjyoungblood/es6-error/\n */\nvar ExtendableError = /** @class */ (function (_super) {\n    __extends(ExtendableError, _super);\n    /**\n     * Constructor for the error.\n     *\n     * @param  {String} message\n     * The error message.\n     */\n    function ExtendableError(message) {\n        var _this = _super.call(this, message) || this;\n        // extending Error is weird and does not propagate `message`\n        Object.defineProperty(_this, 'message', {\n            enumerable: false,\n            value: message,\n        });\n        Object.defineProperty(_this, 'name', {\n            enumerable: false,\n            value: _this.constructor.name,\n        });\n        // Not all browsers have this function.\n        /* istanbul ignore else */\n        if ('captureStackTrace' in Error) {\n            Error.captureStackTrace(_this, _this.constructor);\n        }\n        else {\n            Object.defineProperty(_this, 'stack', {\n                enumerable: false,\n                value: Error(message).stack,\n                writable: true,\n                configurable: true,\n            });\n        }\n        return _this;\n    }\n    return ExtendableError;\n}(Error));\n/**\n * Base error for all Awilix-specific errors.\n */\nvar AwilixError = /** @class */ (function (_super) {\n    __extends(AwilixError, _super);\n    function AwilixError() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return AwilixError;\n}(ExtendableError));\n/**\n * Error thrown to indicate a type mismatch.\n */\nvar AwilixTypeError = /** @class */ (function (_super) {\n    __extends(AwilixTypeError, _super);\n    /**\n     * Constructor, takes the function name, expected and given\n     * type to produce an error.\n     *\n     * @param {string} funcDescription\n     * Name of the function being guarded.\n     *\n     * @param {string} paramName\n     * The parameter there was an issue with.\n     *\n     * @param {string} expectedType\n     * Name of the expected type.\n     *\n     * @param {string} givenType\n     * Name of the given type.\n     */\n    function AwilixTypeError(funcDescription, paramName, expectedType, givenType) {\n        return _super.call(this, \"\".concat(funcDescription, \": expected \").concat(paramName, \" to be \").concat(expectedType, \", but got \").concat(givenType, \".\")) || this;\n    }\n    /**\n     * Asserts the given condition, throws an error otherwise.\n     *\n     * @param {*} condition\n     * The condition to check\n     *\n     * @param {string} funcDescription\n     * Name of the function being guarded.\n     *\n     * @param {string} paramName\n     * The parameter there was an issue with.\n     *\n     * @param {string} expectedType\n     * Name of the expected type.\n     *\n     * @param {string} givenType\n     * Name of the given type.\n     */\n    AwilixTypeError.assert = function (condition, funcDescription, paramName, expectedType, givenType) {\n        if (!condition) {\n            throw new AwilixTypeError(funcDescription, paramName, expectedType, givenType);\n        }\n        return condition;\n    };\n    return AwilixTypeError;\n}(AwilixError));\n/**\n * A nice error class so we can do an instanceOf check.\n */\nvar AwilixResolutionError = /** @class */ (function (_super) {\n    __extends(AwilixResolutionError, _super);\n    /**\n     * Constructor, takes the registered modules and unresolved tokens\n     * to create a message.\n     *\n     * @param {string|symbol} name\n     * The name of the module that could not be resolved.\n     *\n     * @param  {string[]} resolutionStack\n     * The current resolution stack\n     */\n    function AwilixResolutionError(name, resolutionStack, message) {\n        var stringName = name.toString();\n        var nameStack = resolutionStack.map(function (_a) {\n            var val = _a.name;\n            return val.toString();\n        });\n        nameStack.push(stringName);\n        var resolutionPathString = nameStack.join(' -> ');\n        var msg = \"Could not resolve '\".concat(stringName, \"'.\");\n        if (message) {\n            msg += \" \".concat(message);\n        }\n        msg += EOL + EOL;\n        msg += \"Resolution path: \".concat(resolutionPathString);\n        return _super.call(this, msg) || this;\n    }\n    return AwilixResolutionError;\n}(AwilixError));\n/**\n * A nice error class so we can do an instanceOf check.\n */\nvar AwilixRegistrationError = /** @class */ (function (_super) {\n    __extends(AwilixRegistrationError, _super);\n    /**\n     * Constructor, takes the registered modules and unresolved tokens\n     * to create a message.\n     *\n     * @param {string|symbol} name\n     * The name of the module that could not be registered.\n     */\n    function AwilixRegistrationError(name, message) {\n        var stringName = name.toString();\n        var msg = \"Could not register '\".concat(stringName, \"'.\");\n        if (message) {\n            msg += \" \".concat(message);\n        }\n        return _super.call(this, msg) || this;\n    }\n    return AwilixRegistrationError;\n}(AwilixError));\n\n/**\n * Resolution modes.\n */\nvar InjectionMode = {\n    /**\n     * The dependencies will be resolved by injecting the cradle proxy.\n     *\n     * @type {String}\n     */\n    PROXY: 'PROXY',\n    /**\n     * The dependencies will be resolved by inspecting parameter names of the function/constructor.\n     *\n     * @type {String}\n     */\n    CLASSIC: 'CLASSIC',\n};\n\n/**\n * Lifetime types.\n */\nvar Lifetime = {\n    /**\n     * The registration will be resolved once and only once.\n     * @type {String}\n     */\n    SINGLETON: 'SINGLETON',\n    /**\n     * The registration will be resolved every time (never cached).\n     * @type {String}\n     */\n    TRANSIENT: 'TRANSIENT',\n    /**\n     * The registration will be resolved once per scope.\n     * @type {String}\n     */\n    SCOPED: 'SCOPED',\n};\n/**\n * Returns true if and only if the first lifetime is strictly longer than the second.\n */\nfunction isLifetimeLonger(a, b) {\n    return ((a === Lifetime.SINGLETON && b !== Lifetime.SINGLETON) ||\n        (a === Lifetime.SCOPED && b === Lifetime.TRANSIENT));\n}\n\n/**\n * Creates a tokenizer for the specified source.\n *\n * @param source\n */\nfunction createTokenizer(source) {\n    var end = source.length;\n    var pos = 0;\n    var type = 'EOF';\n    var value = '';\n    var flags = 0 /* TokenizerFlags.None */;\n    // These are used to greedily skip as much as possible.\n    // Whenever we reach a paren, we increment these.\n    var parenLeft = 0;\n    var parenRight = 0;\n    return {\n        next: next,\n        done: done,\n    };\n    /**\n     * Advances the tokenizer and returns the next token.\n     */\n    function next(nextFlags) {\n        if (nextFlags === void 0) { nextFlags = 0 /* TokenizerFlags.None */; }\n        flags = nextFlags;\n        advance();\n        return createToken();\n    }\n    /**\n     * Advances the tokenizer state.\n     */\n    function advance() {\n        value = '';\n        type = 'EOF';\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (pos >= end) {\n                return (type = 'EOF');\n            }\n            var ch = source.charAt(pos);\n            // Whitespace is irrelevant\n            if (isWhiteSpace(ch)) {\n                pos++;\n                continue;\n            }\n            switch (ch) {\n                case '(':\n                    pos++;\n                    parenLeft++;\n                    return (type = ch);\n                case ')':\n                    pos++;\n                    parenRight++;\n                    return (type = ch);\n                case '*':\n                    pos++;\n                    return (type = ch);\n                case ',':\n                    pos++;\n                    return (type = ch);\n                case '=':\n                    pos++;\n                    if ((flags & 1 /* TokenizerFlags.Dumb */) === 0) {\n                        // Not in dumb-mode, so attempt to skip.\n                        skipExpression();\n                    }\n                    // We need to know that there's a default value so we can\n                    // skip it if it does not exist when resolving.\n                    return (type = ch);\n                case '/': {\n                    pos++;\n                    var nextCh = source.charAt(pos);\n                    if (nextCh === '/') {\n                        skipUntil(function (c) { return c === '\\n'; }, true);\n                        pos++;\n                    }\n                    if (nextCh === '*') {\n                        skipUntil(function (c) {\n                            var closing = source.charAt(pos + 1);\n                            return c === '*' && closing === '/';\n                        }, true);\n                        pos++;\n                    }\n                    continue;\n                }\n                default:\n                    // Scans an identifier.\n                    if (isIdentifierStart(ch)) {\n                        scanIdentifier();\n                        return type;\n                    }\n                    // Elegantly skip over tokens we don't care about.\n                    pos++;\n            }\n        }\n    }\n    /**\n     * Scans an identifier, given it's already been proven\n     * we are ready to do so.\n     */\n    function scanIdentifier() {\n        var identStart = source.charAt(pos);\n        var start = ++pos;\n        while (isIdentifierPart(source.charAt(pos))) {\n            pos++;\n        }\n        value = '' + identStart + source.substring(start, pos);\n        type = value === 'function' || value === 'class' ? value : 'ident';\n        if (type !== 'ident') {\n            value = '';\n        }\n        return value;\n    }\n    /**\n     * Skips everything until the next comma or the end of the parameter list.\n     * Checks the parenthesis balance so we correctly skip function calls.\n     */\n    function skipExpression() {\n        skipUntil(function (ch) {\n            var isAtRoot = parenLeft === parenRight + 1;\n            if (ch === ',' && isAtRoot) {\n                return true;\n            }\n            if (ch === '(') {\n                parenLeft++;\n                return false;\n            }\n            if (ch === ')') {\n                parenRight++;\n                if (isAtRoot) {\n                    return true;\n                }\n            }\n            return false;\n        });\n    }\n    /**\n     * Skips strings and whilespace until the predicate is true.\n     *\n     * @param callback stops skipping when this returns `true`.\n     * @param dumb if `true`, does not skip whitespace and strings;\n     * it only stops once the callback returns `true`.\n     */\n    function skipUntil(callback, dumb) {\n        if (dumb === void 0) { dumb = false; }\n        while (pos < source.length) {\n            var ch = source.charAt(pos);\n            if (callback(ch)) {\n                return;\n            }\n            if (!dumb) {\n                if (isWhiteSpace(ch)) {\n                    pos++;\n                    continue;\n                }\n                if (isStringQuote(ch)) {\n                    skipString();\n                    continue;\n                }\n            }\n            pos++;\n        }\n    }\n    /**\n     * Given the current position is at a string quote, skips the entire string.\n     */\n    function skipString() {\n        var quote = source.charAt(pos);\n        pos++;\n        while (pos < source.length) {\n            var ch = source.charAt(pos);\n            var prev = source.charAt(pos - 1);\n            // Checks if the quote was escaped.\n            if (ch === quote && prev !== '\\\\') {\n                pos++;\n                return;\n            }\n            // Template strings are a bit tougher, we want to skip the interpolated values.\n            if (quote === '`') {\n                var next_1 = source.charAt(pos + 1);\n                if (next_1 === '$') {\n                    var afterDollar = source.charAt(pos + 2);\n                    if (afterDollar === '{') {\n                        // This is the start of an interpolation; skip the ${\n                        pos = pos + 2;\n                        // Skip strings and whitespace until we reach the ending }.\n                        // This includes skipping nested interpolated strings. :D\n                        skipUntil(function (ch) { return ch === '}'; });\n                    }\n                }\n            }\n            pos++;\n        }\n    }\n    /**\n     * Creates a token from the current state.\n     */\n    function createToken() {\n        if (value) {\n            return { value: value, type: type };\n        }\n        return { type: type };\n    }\n    /**\n     * Determines if we are done parsing.\n     */\n    function done() {\n        return type === 'EOF';\n    }\n}\n/**\n * Determines if the given character is a whitespace character.\n *\n * @param  {string}  ch\n * @return {boolean}\n */\nfunction isWhiteSpace(ch) {\n    switch (ch) {\n        case '\\r':\n        case '\\n':\n        case ' ':\n            return true;\n    }\n    return false;\n}\n/**\n * Determines if the specified character is a string quote.\n * @param  {string}  ch\n * @return {boolean}\n */\nfunction isStringQuote(ch) {\n    switch (ch) {\n        case \"'\":\n        case '\"':\n        case '`':\n            return true;\n    }\n    return false;\n}\n// NOTE: I've added the `.` character so that member expression paths\n// are seen as identifiers. This is so we don't get a constructor token for\n// stuff like `MyClass.prototype.constructor()`\nvar IDENT_START_EXPR = /^[_$a-zA-Z\\xA0-\\uFFFF]$/;\nvar IDENT_PART_EXPR = /^[._$a-zA-Z0-9\\xA0-\\uFFFF]$/;\n/**\n * Determines if the character is a valid JS identifier start character.\n */\nfunction isIdentifierStart(ch) {\n    return IDENT_START_EXPR.test(ch);\n}\n/**\n * Determines if the character is a valid JS identifier start character.\n */\nfunction isIdentifierPart(ch) {\n    return IDENT_PART_EXPR.test(ch);\n}\n\n/**\n * Creates a { name: value } object if the input isn't already in that format.\n *\n * @param  {string|object} name\n * Either a string or an object.\n *\n * @param  {*} value\n * The value, only used if name is not an object.\n *\n * @return {object}\n */\nfunction nameValueToObject(name, value) {\n    var _a;\n    var obj = name;\n    if (typeof obj === 'string' || typeof obj === 'symbol') {\n        return _a = {}, _a[name] = value, _a;\n    }\n    return obj;\n}\n/**\n * Returns the last item in the array.\n *\n * @param  {*[]} arr\n * The array.\n *\n * @return {*}\n * The last element.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n/**\n * Determines if the given function is a class.\n *\n * @param  {Function} fn\n * @return {boolean}\n */\nfunction isClass(\n// eslint-disable-next-line @typescript-eslint/ban-types\nfn) {\n    /*tslint:disable-next-line*/\n    if (typeof fn !== 'function') {\n        return false;\n    }\n    // Should only need 2 tokens.\n    var tokenizer = createTokenizer(fn.toString());\n    var first = tokenizer.next();\n    if (first.type === 'class') {\n        return true;\n    }\n    var second = tokenizer.next();\n    if (first.type === 'function' && second.value) {\n        if (second.value[0] === second.value[0].toUpperCase()) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Determines if the given value is a function.\n *\n * @param  {unknown} val\n * Any value to check if it's a function.\n *\n * @return {boolean}\n * true if the value is a function, false otherwise.\n */\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\n/**\n * Returns the unique items in the array.\n *\n * @param {Array<T>}\n * The array to remove dupes from.\n *\n * @return {Array<T>}\n * The deduped array.\n */\nfunction uniq(arr) {\n    return Array.from(new Set(arr));\n}\n\n/*\n * Parses the parameter list of a function string, including ES6 class constructors.\n *\n * @param {string} source\n * The source of a function to extract the parameter list from\n *\n * @return {Array<Parameter> | null}\n * Returns an array of parameters, or `null` if no\n * constructor was found for a class.\n */\nfunction parseParameterList(source) {\n    var _a = createTokenizer(source), _next = _a.next, done = _a.done;\n    var params = [];\n    var t = null;\n    nextToken();\n    while (!done()) {\n        switch (t.type) {\n            case 'class':\n                skipUntilConstructor();\n                // If we didn't find a constructor token, then we know that there\n                // are no dependencies in the defined class.\n                if (!isConstructorToken()) {\n                    return null;\n                }\n                // Next token is the constructor identifier.\n                nextToken();\n                break;\n            case 'function': {\n                var next = nextToken();\n                if (next.type === 'ident' || next.type === '*') {\n                    // This is the function name or a generator star. Skip it.\n                    nextToken();\n                }\n                break;\n            }\n            case '(':\n                // Start parsing parameter names.\n                parseParams();\n                break;\n            case ')':\n                // We're now out of the parameter list.\n                return params;\n            case 'ident': {\n                // Likely a paren-less arrow function\n                // which can have no default args.\n                var param = { name: t.value, optional: false };\n                if (t.value === 'async') {\n                    // Given it's the very first token, we can assume it's an async function,\n                    // so skip the async keyword if the next token is not an equals sign, in which\n                    // case it is a single-arg arrow func.\n                    var next = nextToken();\n                    if (next && next.type !== '=') {\n                        break;\n                    }\n                }\n                params.push(param);\n                return params;\n            }\n            /* istanbul ignore next */\n            default:\n                throw unexpected();\n        }\n    }\n    return params;\n    /**\n     * After having been placed within the parameter list of\n     * a function, parses the parameters.\n     */\n    function parseParams() {\n        // Current token is a left-paren\n        var param = { name: '', optional: false };\n        while (!done()) {\n            nextToken();\n            switch (t.type) {\n                case 'ident':\n                    param.name = t.value;\n                    break;\n                case '=':\n                    param.optional = true;\n                    break;\n                case ',':\n                    params.push(param);\n                    param = { name: '', optional: false };\n                    break;\n                case ')':\n                    if (param.name) {\n                        params.push(param);\n                    }\n                    return;\n                /* istanbul ignore next */\n                default:\n                    throw unexpected();\n            }\n        }\n    }\n    /**\n     * Skips until we reach the constructor identifier.\n     */\n    function skipUntilConstructor() {\n        while (!isConstructorToken() && !done()) {\n            nextToken(1 /* TokenizerFlags.Dumb */);\n        }\n    }\n    /**\n     * Determines if the current token represents a constructor, and the next token after it is a paren\n     * @return {boolean}\n     */\n    function isConstructorToken() {\n        return t.type === 'ident' && t.value === 'constructor';\n    }\n    /**\n     * Advances the tokenizer and stores the previous token in history\n     */\n    function nextToken(flags) {\n        if (flags === void 0) { flags = 0 /* TokenizerFlags.None */; }\n        t = _next(flags);\n        return t;\n    }\n    /**\n     * Returns an error describing an unexpected token.\n     */\n    /* istanbul ignore next */\n    function unexpected() {\n        return new SyntaxError(\"Parsing parameter list, did not expect \".concat(t.type, \" token\").concat(t.value ? \" (\".concat(t.value, \")\") : ''));\n    }\n}\n\n// We parse the signature of any `Function`, so we want to allow `Function` types.\n/* eslint-disable @typescript-eslint/ban-types */\n/**\n * RESOLVER symbol can be used by modules loaded by\n * `loadModules` to configure their lifetime, injection mode, etc.\n */\nvar RESOLVER = Symbol('Awilix Resolver Config');\n/**\n * Creates a simple value resolver where the given value will always be resolved. The value is\n * marked as leak-safe since in strict mode, the value will only be resolved when it is not leaking\n * upwards from a child scope to a parent singleton.\n *\n * @param  {string} name The name to register the value as.\n *\n * @param  {*} value The value to resolve.\n *\n * @return {object} The resolver.\n */\nfunction asValue(value) {\n    return {\n        resolve: function () { return value; },\n        isLeakSafe: true,\n    };\n}\n/**\n * Creates a factory resolver, where the given factory function\n * will be invoked with `new` when requested.\n *\n * @param  {string} name\n * The name to register the value as.\n *\n * @param  {Function} fn\n * The function to register.\n *\n * @param {object} opts\n * Additional options for the resolver.\n *\n * @return {object}\n * The resolver.\n */\nfunction asFunction(fn, opts) {\n    if (!isFunction(fn)) {\n        throw new AwilixTypeError('asFunction', 'fn', 'function', fn);\n    }\n    var defaults = {\n        lifetime: Lifetime.TRANSIENT,\n    };\n    opts = makeOptions(defaults, opts, fn[RESOLVER]);\n    var resolve = generateResolve(fn);\n    var result = __assign({ resolve: resolve }, opts);\n    return createDisposableResolver(createBuildResolver(result));\n}\n/**\n * Like a factory resolver, but for classes that require `new`.\n *\n * @param  {string} name\n * The name to register the value as.\n *\n * @param  {Class} Type\n * The function to register.\n *\n * @param {object} opts\n * Additional options for the resolver.\n *\n * @return {object}\n * The resolver.\n */\nfunction asClass(Type, opts) {\n    if (!isFunction(Type)) {\n        throw new AwilixTypeError('asClass', 'Type', 'class', Type);\n    }\n    var defaults = {\n        lifetime: Lifetime.TRANSIENT,\n    };\n    opts = makeOptions(defaults, opts, Type[RESOLVER]);\n    // A function to handle object construction for us, as to make the generateResolve more reusable\n    var newClass = function newClass() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return Reflect.construct(Type, args);\n    };\n    var resolve = generateResolve(newClass, Type);\n    return createDisposableResolver(createBuildResolver(__assign(__assign({}, opts), { resolve: resolve })));\n}\n/**\n * Resolves to the specified registration. Marked as leak-safe since the alias target is what should\n * be checked for lifetime leaks.\n */\nfunction aliasTo(name) {\n    return {\n        resolve: function (container) {\n            return container.resolve(name);\n        },\n        isLeakSafe: true,\n    };\n}\n/**\n * Given an options object, creates a fluid interface\n * to manage it.\n *\n * @param {*} obj\n * The object to return.\n *\n * @return {object}\n * The interface.\n */\nfunction createBuildResolver(obj) {\n    function setLifetime(value) {\n        return createBuildResolver(__assign(__assign({}, this), { lifetime: value }));\n    }\n    function setInjectionMode(value) {\n        return createBuildResolver(__assign(__assign({}, this), { injectionMode: value }));\n    }\n    function inject(injector) {\n        return createBuildResolver(__assign(__assign({}, this), { injector: injector }));\n    }\n    return updateResolver(obj, {\n        setLifetime: setLifetime,\n        inject: inject,\n        transient: partial(setLifetime, Lifetime.TRANSIENT),\n        scoped: partial(setLifetime, Lifetime.SCOPED),\n        singleton: partial(setLifetime, Lifetime.SINGLETON),\n        setInjectionMode: setInjectionMode,\n        proxy: partial(setInjectionMode, InjectionMode.PROXY),\n        classic: partial(setInjectionMode, InjectionMode.CLASSIC),\n    });\n}\n/**\n * Given a resolver, returns an object with methods to manage the disposer\n * function.\n * @param obj\n */\nfunction createDisposableResolver(obj) {\n    function disposer(dispose) {\n        return createDisposableResolver(__assign(__assign({}, this), { dispose: dispose }));\n    }\n    return updateResolver(obj, {\n        disposer: disposer,\n    });\n}\n/**\n * Partially apply arguments to the given function.\n */\nfunction partial(fn, arg1) {\n    return function partiallyApplied() {\n        return fn.call(this, arg1);\n    };\n}\n/**\n * Makes an options object based on defaults.\n *\n * @param  {object} defaults\n * Default options.\n *\n * @param  {...} rest\n * The input to check and possibly assign to the resulting object\n *\n * @return {object}\n */\nfunction makeOptions(defaults) {\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        rest[_i - 1] = arguments[_i];\n    }\n    return Object.assign.apply(Object, __spreadArray([{}, defaults], rest, false));\n}\n/**\n * Creates a new resolver with props merged from both.\n *\n * @param source\n * @param target\n */\nfunction updateResolver(source, target) {\n    var result = __assign(__assign({}, source), target);\n    return result;\n}\n/**\n * Returns a wrapped `resolve` function that provides values\n * from the injector and defers to `container.resolve`.\n *\n * @param  {AwilixContainer} container\n * @param  {Object} locals\n * @return {Function}\n */\nfunction wrapWithLocals(container, locals) {\n    return function wrappedResolve(name, resolveOpts) {\n        if (name in locals) {\n            return locals[name];\n        }\n        return container.resolve(name, resolveOpts);\n    };\n}\n/**\n * Returns a new Proxy that checks the result from `injector`\n * for values before delegating to the actual container.\n *\n * @param  {Object} cradle\n * @param  {Function} injector\n * @return {Proxy}\n */\nfunction createInjectorProxy(container, injector) {\n    var locals = injector(container);\n    var allKeys = uniq(__spreadArray(__spreadArray([], Reflect.ownKeys(container.cradle), true), Reflect.ownKeys(locals), true));\n    // TODO: Lots of duplication here from the container proxy.\n    // Need to refactor.\n    var proxy = new Proxy({}, {\n        /**\n         * Resolves the value by first checking the locals, then the container.\n         */\n        get: function (target, name) {\n            if (name === Symbol.iterator) {\n                return function iterateRegistrationsAndLocals() {\n                    var _a, _b, _c, _i, prop, _d, _e, _f, _g, prop;\n                    return __generator(this, function (_h) {\n                        switch (_h.label) {\n                            case 0:\n                                _a = container.cradle;\n                                _b = [];\n                                for (_c in _a)\n                                    _b.push(_c);\n                                _i = 0;\n                                _h.label = 1;\n                            case 1:\n                                if (!(_i < _b.length)) return [3 /*break*/, 4];\n                                _c = _b[_i];\n                                if (!(_c in _a)) return [3 /*break*/, 3];\n                                prop = _c;\n                                return [4 /*yield*/, prop];\n                            case 2:\n                                _h.sent();\n                                _h.label = 3;\n                            case 3:\n                                _i++;\n                                return [3 /*break*/, 1];\n                            case 4:\n                                _d = locals;\n                                _e = [];\n                                for (_f in _d)\n                                    _e.push(_f);\n                                _g = 0;\n                                _h.label = 5;\n                            case 5:\n                                if (!(_g < _e.length)) return [3 /*break*/, 8];\n                                _f = _e[_g];\n                                if (!(_f in _d)) return [3 /*break*/, 7];\n                                prop = _f;\n                                return [4 /*yield*/, prop];\n                            case 6:\n                                _h.sent();\n                                _h.label = 7;\n                            case 7:\n                                _g++;\n                                return [3 /*break*/, 5];\n                            case 8: return [2 /*return*/];\n                        }\n                    });\n                };\n            }\n            if (name in locals) {\n                return locals[name];\n            }\n            return container.resolve(name);\n        },\n        /**\n         * Used for `Object.keys`.\n         */\n        ownKeys: function () {\n            return allKeys;\n        },\n        /**\n         * Used for `Object.keys`.\n         */\n        getOwnPropertyDescriptor: function (target, key) {\n            if (allKeys.indexOf(key) > -1) {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            }\n            return undefined;\n        },\n    });\n    return proxy;\n}\n/**\n * Returns a resolve function used to construct the dependency graph\n *\n * @this {Registration}\n * The `this` context is a resolver.\n *\n * @param {Function} fn\n * The function to construct\n *\n * @param {Function} dependencyParseTarget\n * The function to parse for the dependencies of the construction target\n *\n * @param {boolean} isFunction\n * Is the resolution target an actual function or a mask for a constructor?\n *\n * @return {Function}\n * The function used for dependency resolution\n */\nfunction generateResolve(fn, dependencyParseTarget) {\n    // If the function used for dependency parsing is falsy, use the supplied function\n    if (!dependencyParseTarget) {\n        dependencyParseTarget = fn;\n    }\n    // Parse out the dependencies\n    // NOTE: we do this regardless of whether PROXY is used or not,\n    // because if this fails, we want it to fail early (at startup) rather\n    // than at resolution time.\n    var dependencies = parseDependencies(dependencyParseTarget);\n    // Use a regular function instead of an arrow function to facilitate binding to the resolver.\n    return function resolve(container) {\n        // Because the container holds a global reolutionMode we need to determine it in the proper order of precedence:\n        // resolver -> container -> default value\n        var injectionMode = this.injectionMode ||\n            container.options.injectionMode ||\n            InjectionMode.PROXY;\n        if (injectionMode !== InjectionMode.CLASSIC) {\n            // If we have a custom injector, we need to wrap the cradle.\n            var cradle = this.injector\n                ? createInjectorProxy(container, this.injector)\n                : container.cradle;\n            // Return the target injected with the cradle\n            return fn(cradle);\n        }\n        // We have dependencies so we need to resolve them manually\n        if (dependencies.length > 0) {\n            var resolve_1 = this.injector\n                ? wrapWithLocals(container, this.injector(container))\n                : container.resolve;\n            var children = dependencies.map(function (p) {\n                return resolve_1(p.name, { allowUnregistered: p.optional });\n            });\n            return fn.apply(void 0, children);\n        }\n        return fn();\n    };\n}\n/**\n * Parses the dependencies from the given function.\n * If it's a class that extends another class, and it does\n * not have a defined constructor, attempt to parse it's super constructor.\n */\nfunction parseDependencies(fn) {\n    var result = parseParameterList(fn.toString());\n    if (!result) {\n        // No defined constructor for a class, check if there is a parent\n        // we can parse.\n        var parent = Object.getPrototypeOf(fn);\n        if (typeof parent === 'function' && parent !== Function.prototype) {\n            // Try to parse the parent\n            return parseDependencies(parent);\n        }\n        return [];\n    }\n    return result;\n}\n\n/**\n * Family tree symbol.\n */\nvar FAMILY_TREE = Symbol('familyTree');\n/**\n * Roll Up Registrations symbol.\n */\nvar ROLL_UP_REGISTRATIONS = Symbol('rollUpRegistrations');\n/**\n * The string representation when calling toString.\n */\nvar CRADLE_STRING_TAG = 'AwilixContainerCradle';\n/**\n * Creates an Awilix container instance.\n *\n * @param {Function} options.require The require function to use. Defaults to require.\n *\n * @param {string} options.injectionMode The mode used by the container to resolve dependencies.\n * Defaults to 'Proxy'.\n *\n * @param {boolean} options.strict True if the container should run in strict mode with additional\n * validation for resolver configuration correctness. Defaults to false.\n *\n * @return {AwilixContainer<T>} The container.\n */\nfunction createContainer(options) {\n    if (options === void 0) { options = {}; }\n    return createContainerInternal(options);\n}\nfunction createContainerInternal(options, parentContainer, parentResolutionStack) {\n    var _a;\n    options = __assign({ injectionMode: InjectionMode.PROXY, strict: false }, options);\n    /**\n     * Tracks the names and lifetimes of the modules being resolved. Used to detect circular\n     * dependencies and, in strict mode, lifetime leakage issues.\n     */\n    var resolutionStack = parentResolutionStack !== null && parentResolutionStack !== void 0 ? parentResolutionStack : [];\n    // Internal registration store for this container.\n    var registrations = {};\n    /**\n     * The `Proxy` that is passed to functions so they can resolve their dependencies without\n     * knowing where they come from. I call it the \"cradle\" because\n     * it is where registered things come to life at resolution-time.\n     */\n    var cradle = new Proxy({\n    /* removed in browser build */\n    }, {\n        /**\n         * The `get` handler is invoked whenever a get-call for `container.cradle.*` is made.\n         *\n         * @param  {object} _target\n         * The proxy target. Irrelevant.\n         *\n         * @param  {string} name\n         * The property name.\n         *\n         * @return {*}\n         * Whatever the resolve call returns.\n         */\n        get: function (_target, name) { return resolve(name); },\n        /**\n         * Setting things on the cradle throws an error.\n         *\n         * @param  {object} target\n         * @param  {string} name\n         */\n        set: function (_target, name) {\n            throw new Error(\"Attempted setting property \\\"\".concat(name, \"\\\" on container cradle - this is not allowed.\"));\n        },\n        /**\n         * Used for `Object.keys`.\n         */\n        ownKeys: function () {\n            return Array.from(cradle);\n        },\n        /**\n         * Used for `Object.keys`.\n         */\n        getOwnPropertyDescriptor: function (target, key) {\n            var regs = rollUpRegistrations();\n            if (Object.getOwnPropertyDescriptor(regs, key)) {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            }\n            return undefined;\n        },\n    });\n    // The container being exposed.\n    var container = (_a = {\n            options: options,\n            cradle: cradle,\n            inspect: inspect,\n            cache: new Map(),\n            loadModules: function () { throw new Error(\"loadModules is not supported in the browser.\"); },\n            createScope: createScope,\n            register: register,\n            build: build,\n            resolve: resolve,\n            hasRegistration: hasRegistration,\n            dispose: dispose,\n            getRegistration: getRegistration\n        },\n        /* removed in browser build */\n        // tslint:disable-next-line\n        _a[ROLL_UP_REGISTRATIONS] = rollUpRegistrations,\n        Object.defineProperty(_a, \"registrations\", {\n            get: function () {\n                return rollUpRegistrations();\n            },\n            enumerable: false,\n            configurable: true\n        }),\n        _a);\n    // Track the family tree.\n    var familyTree = parentContainer\n        ? [container].concat(parentContainer[FAMILY_TREE])\n        : [container];\n    container[FAMILY_TREE] = familyTree;\n    // We need a reference to the root container,\n    // so we can retrieve and store singletons.\n    var rootContainer = last(familyTree);\n    return container;\n    /**\n     * Used by util.inspect (which is used by console.log).\n     */\n    function inspect() {\n        return \"[AwilixContainer (\".concat(parentContainer ? 'scoped, ' : '', \"registrations: \").concat(Object.keys(container.registrations).length, \")]\");\n    }\n    /**\n     * Rolls up registrations from the family tree.\n     *\n     * This can get pretty expensive. Only used when\n     * iterating the cradle proxy, which is not something\n     * that should be done in day-to-day use, mostly for debugging.\n     *\n     * @param {boolean} bustCache\n     * Forces a recomputation.\n     *\n     * @return {object}\n     * The merged registrations object.\n     */\n    function rollUpRegistrations() {\n        return __assign(__assign({}, (parentContainer && parentContainer[ROLL_UP_REGISTRATIONS]())), registrations);\n    }\n    /**\n     * Used for providing an iterator to the cradle.\n     */\n    function cradleIterator() {\n        var registrations, _a, _b, _c, _i, registrationName;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0:\n                    registrations = rollUpRegistrations();\n                    _a = registrations;\n                    _b = [];\n                    for (_c in _a)\n                        _b.push(_c);\n                    _i = 0;\n                    _d.label = 1;\n                case 1:\n                    if (!(_i < _b.length)) return [3 /*break*/, 4];\n                    _c = _b[_i];\n                    if (!(_c in _a)) return [3 /*break*/, 3];\n                    registrationName = _c;\n                    return [4 /*yield*/, registrationName];\n                case 2:\n                    _d.sent();\n                    _d.label = 3;\n                case 3:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    }\n    /**\n     * Creates a scoped container.\n     *\n     * @return {object}\n     * The scoped container.\n     */\n    function createScope() {\n        return createContainerInternal(options, container, resolutionStack);\n    }\n    /**\n     * Adds a registration for a resolver.\n     */\n    function register(arg1, arg2) {\n        var obj = nameValueToObject(arg1, arg2);\n        var keys = __spreadArray(__spreadArray([], Object.keys(obj), true), Object.getOwnPropertySymbols(obj), true);\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            var resolver = obj[key];\n            // If strict mode is enabled, check to ensure we are not registering a singleton on a non-root\n            // container.\n            if (options.strict && resolver.lifetime === Lifetime.SINGLETON) {\n                if (parentContainer) {\n                    throw new AwilixRegistrationError(key, 'Cannot register a singleton on a scoped container.');\n                }\n            }\n            registrations[key] = resolver;\n        }\n        return container;\n    }\n    /**\n     * Returned to `util.inspect` and Symbol.toStringTag when attempting to resolve\n     * a custom inspector function on the cradle.\n     */\n    function toStringRepresentationFn() {\n        return Object.prototype.toString.call(cradle);\n    }\n    /**\n     * Recursively gets a registration by name if it exists in the\n     * current container or any of its' parents.\n     *\n     * @param name {string | symbol} The registration name.\n     */\n    function getRegistration(name) {\n        var resolver = registrations[name];\n        if (resolver) {\n            return resolver;\n        }\n        if (parentContainer) {\n            return parentContainer.getRegistration(name);\n        }\n        return null;\n    }\n    /**\n     * Resolves the registration with the given name.\n     *\n     * @param {string | symbol} name\n     * The name of the registration to resolve.\n     *\n     * @param {ResolveOptions} resolveOpts\n     * The resolve options.\n     *\n     * @return {any}\n     * Whatever was resolved.\n     */\n    function resolve(name, resolveOpts) {\n        resolveOpts = resolveOpts || {};\n        try {\n            // Grab the registration by name.\n            var resolver = getRegistration(name);\n            if (resolutionStack.some(function (_a) {\n                var parentName = _a.name;\n                return parentName === name;\n            })) {\n                throw new AwilixResolutionError(name, resolutionStack, 'Cyclic dependencies detected.');\n            }\n            // Used in JSON.stringify.\n            if (name === 'toJSON') {\n                return toStringRepresentationFn;\n            }\n            // Used in console.log.\n            if (name === 'constructor') {\n                return createContainer;\n            }\n            if (!resolver) {\n                // Checks for some edge cases.\n                switch (name) {\n                    // The following checks ensure that console.log on the cradle does not\n                    // throw an error (issue #7).\n                    case 'inspect':\n                    case 'toString':\n                        return toStringRepresentationFn;\n                    case Symbol.toStringTag:\n                        return CRADLE_STRING_TAG;\n                    // Edge case: Promise unwrapping will look for a \"then\" property and attempt to call it.\n                    // Return undefined so that we won't cause a resolution error. (issue #109)\n                    case 'then':\n                        return undefined;\n                    // When using `Array.from` or spreading the cradle, this will\n                    // return the registration names.\n                    case Symbol.iterator:\n                        return cradleIterator;\n                }\n                if (resolveOpts.allowUnregistered) {\n                    return undefined;\n                }\n                throw new AwilixResolutionError(name, resolutionStack);\n            }\n            var lifetime_1 = resolver.lifetime || Lifetime.TRANSIENT;\n            // if we are running in strict mode, this resolver is not explicitly marked leak-safe, and any\n            // of the parents have a shorter lifetime than the one requested, throw an error.\n            if (options.strict && !resolver.isLeakSafe) {\n                var maybeLongerLifetimeParentIndex = resolutionStack.findIndex(function (_a) {\n                    var parentLifetime = _a.lifetime;\n                    return isLifetimeLonger(parentLifetime, lifetime_1);\n                });\n                if (maybeLongerLifetimeParentIndex > -1) {\n                    throw new AwilixResolutionError(name, resolutionStack, \"Dependency '\".concat(name.toString(), \"' has a shorter lifetime than its ancestor: '\").concat(resolutionStack[maybeLongerLifetimeParentIndex].name.toString(), \"'\"));\n                }\n            }\n            // Pushes the currently-resolving module information onto the stack\n            resolutionStack.push({ name: name, lifetime: lifetime_1 });\n            // Do the thing\n            var cached = void 0;\n            var resolved = void 0;\n            switch (lifetime_1) {\n                case Lifetime.TRANSIENT:\n                    // Transient lifetime means resolve every time.\n                    resolved = resolver.resolve(container);\n                    break;\n                case Lifetime.SINGLETON:\n                    // Singleton lifetime means cache at all times, regardless of scope.\n                    cached = rootContainer.cache.get(name);\n                    if (!cached) {\n                        // if we are running in strict mode, perform singleton resolution using the root\n                        // container only.\n                        resolved = resolver.resolve(options.strict ? rootContainer : container);\n                        rootContainer.cache.set(name, { resolver: resolver, value: resolved });\n                    }\n                    else {\n                        resolved = cached.value;\n                    }\n                    break;\n                case Lifetime.SCOPED:\n                    // Scoped lifetime means that the container\n                    // that resolves the registration also caches it.\n                    // If this container cache does not have it,\n                    // resolve and cache it rather than using the parent\n                    // container's cache.\n                    cached = container.cache.get(name);\n                    if (cached !== undefined) {\n                        // We found one!\n                        resolved = cached.value;\n                        break;\n                    }\n                    // If we still have not found one, we need to resolve and cache it.\n                    resolved = resolver.resolve(container);\n                    container.cache.set(name, { resolver: resolver, value: resolved });\n                    break;\n                default:\n                    throw new AwilixResolutionError(name, resolutionStack, \"Unknown lifetime \\\"\".concat(resolver.lifetime, \"\\\"\"));\n            }\n            // Pop it from the stack again, ready for the next resolution\n            resolutionStack.pop();\n            return resolved;\n        }\n        catch (err) {\n            // When we get an error we need to reset the stack. Mutate the existing array rather than\n            // updating the reference to ensure all parent containers' stacks are also updated.\n            resolutionStack.length = 0;\n            throw err;\n        }\n    }\n    /**\n     * Checks if the registration with the given name exists.\n     *\n     * @param {string | symbol} name\n     * The name of the registration to resolve.\n     *\n     * @return {boolean}\n     * Whether or not the registration exists.\n     */\n    function hasRegistration(name) {\n        return !!getRegistration(name);\n    }\n    /**\n     * Given a registration, class or function, builds it up and returns it.\n     * Does not cache it, this means that any lifetime configured in case of passing\n     * a registration will not be used.\n     *\n     * @param {Resolver|Constructor|Function} targetOrResolver\n     * @param {ResolverOptions} opts\n     */\n    function build(targetOrResolver, opts) {\n        if (targetOrResolver && targetOrResolver.resolve) {\n            return targetOrResolver.resolve(container);\n        }\n        var funcName = 'build';\n        var paramName = 'targetOrResolver';\n        AwilixTypeError.assert(targetOrResolver, funcName, paramName, 'a registration, function or class', targetOrResolver);\n        AwilixTypeError.assert(typeof targetOrResolver === 'function', funcName, paramName, 'a function or class', targetOrResolver);\n        var resolver = isClass(targetOrResolver)\n            ? asClass(targetOrResolver, opts)\n            : asFunction(targetOrResolver, opts);\n        return resolver.resolve(container);\n    }\n    /**\n     * Disposes this container and it's children, calling the disposer\n     * on all disposable registrations and clearing the cache.\n     */\n    function dispose() {\n        var entries = Array.from(container.cache.entries());\n        container.cache.clear();\n        return Promise.all(entries.map(function (_a) {\n            var entry = _a[1];\n            var resolver = entry.resolver, value = entry.value;\n            var disposable = resolver;\n            if (disposable.dispose) {\n                return Promise.resolve().then(function () { return disposable.dispose(value); });\n            }\n            return Promise.resolve();\n        })).then(function () { return undefined; });\n    }\n}\n\nexport { AwilixError, AwilixRegistrationError, AwilixResolutionError, AwilixTypeError, InjectionMode, Lifetime, RESOLVER, aliasTo, asClass, asFunction, asValue, createBuildResolver, createContainer, createDisposableResolver };\n"],
  "mappings": "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",
  "names": ["d", "b", "__assign", "ExtendableError", "AwilixError", "AwilixTypeError", "AwilixResolutionError", "AwilixRegistrationError", "ch", "param", "newClass", "registrations", "_a"]
}
